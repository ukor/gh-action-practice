
name: CI

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - uses: actions/checkout@v4
        with: 
          fetch-depth: 0
      # Runs a set of commands using the runners shell
      - name: Github context
        env:
          GITHUB_CONTEXT: ${{ toJson(github) }}
          BEFORE_PR_SHA: ${{ github.event.before }}
          AFTER_PR_SHA: ${{ github.event.after }}
        run: |
          echo Add other actions to build,
          echo "$GITHUB_CONTEXT"
          echo "$GITHUB_WORKSPACE"

          echo "----------"

          # Exit immediately if a command exits with a non-zero status.
          set -o errexit
          
          # Treat unset variables as an error when substituting.
          # set -o nounset
          
          # The exit status of a pipeline is the status of the last command to exit with a non-zero status.
          set -o pipefail

          git --version
          
          # Declare the associative array
          declare -A changed_files
          
          # Replace these with your actual commit SHAs
          start_commit=$(git rev-parse --short "$BEFORE_PR_SHA")
          end_commit=$(git rev-parse --short "$AFTER_PR_SHA")

          echo "start SHA = $start_commit" " end SHA = $end_commit"

          # git --no-pager diff --name-only FETCH_HEAD $(git merge-base FETCH_HEAD main)
          
          # Capture the output of git diff in a variable
          # files_changed=$(git --no-pager diff --name-only "$start_commit" "$end_commit")

          # Use readarray (or mapfile) to read the newline-separated string
          # and store each line as a new element in the 'file_list'.
          readarray -t file_list < <(git --no-pager diff --name-only "$start_commit" "$end_commit")
          
          echo "--- file list start --"

          echo "$file_list"

          echo "--- file list end --"
          

          # An array to store the unique two-component paths
          declare -a component_list
          
          # Use a temporary associative array to handle uniqueness easily
          declare -A unique_components
          
          for file_path in "${file_list[@]}"; do
            # Check if the path starts with "apps/" or "packages/"
            if [[ "$file_path" =~ ^(apps|packages)/ ]]; then
                # Use IFS to split the path into an array of components
                IFS='/' read -ra path_parts <<< "$file_path"
                
                # Check if the path has at least two components after splitting
                if [[ "${#path_parts[@]}" -gt 1 ]]; then
                    # Construct the two-component path
                    two_component_path="${path_parts[0]}/${path_parts[1]}"
                    
                    # Check if this component path has already been added to the unique_components array
                    # If not, add it. This automatically handles duplicates.
                    if [[ ! -v unique_components["$two_component_path"] ]]; then
                        unique_components["$two_component_path"]=1
                        component_list+=("$two_component_path")
                    fi
                fi
            fi
          done

          echo "****"
          
          # Print the resulting list
          echo "Extracted components:"
          for component in "${component_list[@]}"; do
              echo "- $component"
          done
